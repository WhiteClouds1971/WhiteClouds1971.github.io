<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[knowledge-database]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://whiteclouds1971.github.io/</link><image><url>https://whiteclouds1971.github.io/lib/media/favicon.png</url><title>knowledge-database</title><link>https://whiteclouds1971.github.io/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 09 Apr 2024 02:40:52 GMT</lastBuildDate><atom:link href="https://whiteclouds1971.github.io/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 09 Apr 2024 02:40:52 GMT</pubDate><copyright><![CDATA[白云]]></copyright><ttl>60</ttl><dc:creator>白云</dc:creator><item><title><![CDATA[5. 什么是可变长参数？]]></title><description><![CDATA[<br>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个&nbsp;printVariable&nbsp;方法就可以接受 0 个或者多个参数。<br>public static void method1(String... args) { //......
}
复制<br>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。 <br>public static void method2(String arg1, String... args) { //......
}
复制<br>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？<br>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。 <br>我们通过下面这个例子来证明一下。<br>public class VariableLengthArgument { public static void printVariable(String... args) { for (String s : args) { System.out.println(s); } } public static void printVariable(String arg1, String arg2) { System.out.println(arg1 + arg2); } public static void main(String[] args) { printVariable("a", "b"); printVariable("a", "b", "c", "d"); }
}
复制<br>输出：<br>ab
a
b
c
d
复制<br>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的&nbsp;class文件就可以看出来了。 <br>public class VariableLengthArgument { public static void printVariable(String... args) { String[] var1 = args; int var2 = args.length; for(int var3 = 0; var3 &lt; var2; ++var3) { String s = var1[var3]; System.out.println(s); } } // ......
}
复制]]></description><link>https://whiteclouds1971.github.io/002-每日面试题/java/方法/5.-什么是可变长参数？.html</link><guid isPermaLink="false">002 每日面试题/java/方法/5. 什么是可变长参数？.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 02:40:10 GMT</pubDate></item><item><title><![CDATA[重载]]></title><description><![CDATA[<br>
重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理<br>
重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法
<br><br>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。<br>《Java 核心技术》这本书是这样介绍重载的：<br>
如果多个方法(比如&nbsp;StringBuilder&nbsp;的构造方法)有相同的名字、不同的参数， 便产生了重载。
<br>&gt; StringBuilder sb = new StringBuilder();
&gt; StringBuilder sb2 = new StringBuilder("HelloWorld");
&gt; ``` &gt; 编译器必须挑选出具体执行哪个方法，**它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。** 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。
&gt; &gt; Java 允许重载任何方法， 而不只是构造器方法。 综上：**重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。**
# 重写 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。 1. 方法名、参数列表必须相同，**子类方法返回值类型应比父类方法返回值类型更小或相等**，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写 综上：**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。** 参考表：
![[Pasted image 20240409102758.png]] **方法的重写要遵循“两同两小一大”**（以下内容摘录自《疯狂 Java 讲义》，[issue#892](https://github.com/Snailclimb/JavaGuide/issues/892) ）： - “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。 ⭐️ 关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。 ```java
public class Hero { public String name() { return "超级英雄"; }
}
public class SuperMan extends Hero{ @Override public String name() { return "超人"; } public Hero hero() { return new Hero(); }
} public class SuperSuperMan extends SuperMan { public String name() { return "超级超级英雄"; } @Override public SuperMan hero() { return new SuperMan(); }
}
复制]]></description><link>https://whiteclouds1971.github.io/002-每日面试题/java/方法/4.-重载和重写有什么区别？.html</link><guid isPermaLink="false">002 每日面试题/java/方法/4. 重载和重写有什么区别？.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 02:36:20 GMT</pubDate></item><item><title><![CDATA[3. 静态方法和实例方法有何不同？]]></title><description><![CDATA[<br>在外部调用静态方法时，可以使用&nbsp;类名.方法名&nbsp;的方式，也可以使用&nbsp;对象.方法名&nbsp;的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象&nbsp;。<br>不过，需要注意的是一般不建议使用&nbsp;对象.方法名&nbsp;的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。<br>因此，一般建议使用&nbsp;类名.方法名&nbsp;的方式来调用静态方法。<br>public class Person { public void method() { //...... } public static void staicMethod(){ //...... } public static void main(String[] args) { Person person = new Person(); // 调用实例方法 person.method(); // 调用静态方法 Person.staicMethod() }
}
复制<br>2、访问类成员是否存在限制<br>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。]]></description><link>https://whiteclouds1971.github.io/002-每日面试题/java/方法/3.-静态方法和实例方法有何不同？.html</link><guid isPermaLink="false">002 每日面试题/java/方法/3. 静态方法和实例方法有何不同？.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 02:20:11 GMT</pubDate></item><item><title><![CDATA[2. 静态方法为什么不能调用非静态成员？]]></title><description><![CDATA[<br>这个需要结合 JVM 的相关知识，主要原因如下：<br>
<br>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
<br>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。
<br>public class Example { // 定义一个字符型常量 public static final char LETTER_A = 'A'; // 定义一个字符串常量 public static final String GREETING_MESSAGE = "Hello, world!"; public static void main(String[] args) { // 输出字符型常量的值 System.out.println("字符型常量的值为：" + LETTER_A); // 输出字符串常量的值 System.out.println("字符串常量的值为：" + GREETING_MESSAGE); }
}
复制]]></description><link>https://whiteclouds1971.github.io/002-每日面试题/java/方法/2.-静态方法为什么不能调用非静态成员？.html</link><guid isPermaLink="false">002 每日面试题/java/方法/2. 静态方法为什么不能调用非静态成员？.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 02:17:50 GMT</pubDate></item><item><title><![CDATA[1. 什么是方法的返回值？方法有哪几种类型？]]></title><description><![CDATA[<br>方法的返回值&nbsp;是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！<br>我们可以按照方法的返回值和参数类型将方法分为下面这几种：<br>1、无参数无返回值的方法<br>public void f1() { //......
}
// 下面这个方法也没有返回值，虽然用到了 return
public void f(int a) { if (...) { // 表示结束方法的执行,下方的输出语句不会执行 return; } System.out.println(a);
}
复制<br>2、有参数无返回值的方法<br>public void f2(Parameter 1, ..., Parameter n) { //......
}
复制<br>3、有返回值无参数的方法<br>public int f3() { //...... return x;
}
复制<br>4、有返回值有参数的方法<br>public int f4(int a, int b) { return a * b;
}
复制]]></description><link>https://whiteclouds1971.github.io/002-每日面试题/java/方法/1.-什么是方法的返回值？方法有哪几种类型？.html</link><guid isPermaLink="false">002 每日面试题/java/方法/1. 什么是方法的返回值？方法有哪几种类型？.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 02:16:07 GMT</pubDate></item><item><title><![CDATA[3. 字符形常量和字符串常量的区别？]]></title><description><![CDATA[<br>
<br>形式&nbsp;: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。
<br>含义&nbsp;: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。
<br>占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。
<br>⚠️ 注意&nbsp;char&nbsp;在 Java 中占两个字节。<br>字符型常量和字符串常量代码示例：<br>public class StringExample { // 字符型常量 public static final char LETTER_A = 'A'; // 字符串常量 public static final String GREETING_MESSAGE = "Hello, world!"; public static void main(String[] args) { System.out.println("字符型常量占用的字节数为："+Character.BYTES); System.out.println("字符串常量占用的字节数为："+GREETING_MESSAGE.getBytes().length); }
}
复制<br>输出：<br>字符型常量占用的字节数为：2
字符串常量占用的字节数为：13
复制]]></description><link>https://whiteclouds1971.github.io/002-每日面试题/java/变量/3.-字符形常量和字符串常量的区别？.html</link><guid isPermaLink="false">002 每日面试题/java/变量/3. 字符形常量和字符串常量的区别？.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 02:13:15 GMT</pubDate></item><item><title><![CDATA[2. 静态变量有什么作用]]></title><description><![CDATA[<br>静态变量也就是被&nbsp;static&nbsp;关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。<br>静态变量是通过类名来访问的，例如StaticVariableExample.staticVar（如果被&nbsp;private关键字修饰就无法这样访问了）。<br>public class StaticVariableExample { // 静态变量 public static int staticVar = 0;
}
复制<br>通常情况下，静态变量会被&nbsp;final&nbsp;关键字修饰成为常量。<br>public class ConstantVariableExample { // 常量 public static final int constantVar = 0;
}
复制]]></description><link>https://whiteclouds1971.github.io/002-每日面试题/java/变量/2.-静态变量有什么作用.html</link><guid isPermaLink="false">002 每日面试题/java/变量/2. 静态变量有什么作用.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 02:09:55 GMT</pubDate></item><item><title><![CDATA[EasyExcel 的 @ExcelIgnore]]></title><description><![CDATA[<a class="tag" href="https://whiteclouds1971.github.io/?query=tag:Excel" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Excel</a> <a class="tag" href="https://whiteclouds1971.github.io/?query=tag:导入" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#导入</a> <a class="tag" href="https://whiteclouds1971.github.io/?query=tag:记录" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#记录</a> <br> <a href="https://whiteclouds1971.github.io?query=tag:Excel" class="tag is-unresolved" target="_self" rel="noopener" data-href="#Excel">#Excel</a> <a href="https://whiteclouds1971.github.io?query=tag:导入" class="tag is-unresolved" target="_self" rel="noopener" data-href="#导入">#导入</a> <a href="https://whiteclouds1971.github.io?query=tag:记录" class="tag is-unresolved" target="_self" rel="noopener" data-href="#记录">#记录</a><br>Bug
在使用 EasyExcel 的模板类导入时，需要为模板类中不需要映射的字段增加@ExcelIgnore 注解。否则在导入的时候会识别报错
<br>class ProgressReportExcel { @ExcelProperty("Purchasing Document") var poNumber: String? = null @ExcelIgnore var poNumberChanged = false
}
复制]]></description><link>https://whiteclouds1971.github.io/tp311.1-程序设计/easyexcel-的-@excelignore.html</link><guid isPermaLink="false">TP311.1 程序设计/EasyExcel 的 @ExcelIgnore.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 02:05:59 GMT</pubDate></item><item><title><![CDATA[跨域（CSRF）]]></title><description><![CDATA[<br>
source: <br><a data-tooltip-position="top" aria-label="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" rel="noopener" class="external-link is-unresolved" href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_self">浅谈CSRF攻击方式 - hyddd - 博客园</a>
<br><a data-tooltip-position="top" aria-label="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" rel="noopener" class="external-link is-unresolved" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_self">前端安全系列（二）：如何防止CSRF攻击？ - 美团技术团队</a> <br><br><img alt="Pasted image 20230906111013.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20230906111013.png" target="_self"><br>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：<br>
<br>登录受信任网站A，并在本地生成Cookie。
<br>在不登出A的情况下，访问危险网站B。
<br>browser在发送请求时会自动带上Cookie（CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！）<br>
看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：
<br>你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。
<br>你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了......）
<br>上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。
<br><br>银行网站A，它以GET请求来完成银行转账的操作，如：<a rel="noopener" class="external-link is-unresolved" href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_self">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a><br>// 银行的请求代码
&lt;?php session_start(); if (isset($_POST['toBankId'] &amp;&amp;　isset($_POST['money'])){ buy_stocks($_POST['toBankId'],　$_POST['money']); } ?&gt;
复制<br>// 恶意网站发送的请求
&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript"&gt; function steal(){
iframe = document.frames["steal"]; iframe.document.Submit("transfer"); } &lt;/script&gt; &lt;/head&gt; &lt;body onload="steal()"&gt; &lt;iframe name="steal" display="none"&gt; &lt;form method="POST" name="transfer"　action="http://www.myBank.com/Transfer.php"&gt; &lt;input type="hidden" name="toBankId" value="11"&gt; &lt;input type="hidden" name="money" value="1000"&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;
&lt;/html&gt;
复制<br><br>CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。<br>上文中讲了CSRF的两个特点：<br>
<br>CSRF（通常）发生在第三方域名。
<br>CSRF攻击者不能获取到Cookie等信息，只是使用。
<br>针对这两点，我们可以专门制定防护策略，如下：<br>
<br>阻止不明外域的访问
<br>
<br>同源检测
<br>Samesite Cookie
<br>
<br>提交时要求附加本域才能获取的信息
<br>
<br>CSRF Token
<br>双重Cookie验证
<br>详细防御措施介绍见<a data-tooltip-position="top" aria-label="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" rel="noopener" class="external-link is-unresolved" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_self">前端安全系列（二）：如何防止CSRF攻击？ - 美团技术团队</a><br><br>START<br>
填空题<br>
文字: 跨域攻击的英文简称{{c1::CSRF}}<br>
背面额外: <br><br>END<br>START<br>
问答题<br>
正面: CSRF的原理<br>
背面: <a data-href="跨域（CSRF）#^16b02b" href="https://whiteclouds1971.github.io/tp393-计算机网络/跨域（csrf）.html#^16b02b" class="internal-link" target="_self" rel="noopener">跨域（CSRF） &gt; ^16b02b</a><br><br>END]]></description><link>https://whiteclouds1971.github.io/tp393-计算机网络/跨域（csrf）.html</link><guid isPermaLink="false">TP393 计算机网络/跨域（CSRF）.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Sun, 07 Apr 2024 12:10:35 GMT</pubDate><enclosure url="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20230906111013.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20230906111013.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>