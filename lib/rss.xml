<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[knowledge-database]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://whiteclouds1971.github.io/</link><image><url>https://whiteclouds1971.github.io/lib/media/favicon.png</url><title>knowledge-database</title><link>https://whiteclouds1971.github.io/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 09 Apr 2024 03:53:05 GMT</lastBuildDate><atom:link href="https://whiteclouds1971.github.io/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 09 Apr 2024 03:53:05 GMT</pubDate><copyright><![CDATA[白云]]></copyright><ttl>60</ttl><dc:creator>白云</dc:creator><item><title><![CDATA[认识微服务]]></title><description><![CDATA[<a class="tag" href="https://whiteclouds1971.github.io/?query=tag:微服务" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#微服务</a> <a class="tag" href="https://whiteclouds1971.github.io/?query=tag:注册中心" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#注册中心</a> <a class="tag" href="https://whiteclouds1971.github.io/?query=tag:负载均衡" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#负载均衡</a> <br> <a href="https://whiteclouds1971.github.io?query=tag:微服务" class="tag is-unresolved" target="_self" rel="noopener" data-href="#微服务">#微服务</a> <a href="https://whiteclouds1971.github.io?query=tag:注册中心" class="tag is-unresolved" target="_self" rel="noopener" data-href="#注册中心">#注册中心</a> <a href="https://whiteclouds1971.github.io?query=tag:负载均衡" class="tag is-unresolved" target="_self" rel="noopener" data-href="#负载均衡">#负载均衡</a><br><img alt="Pasted image 20240328161731.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328161731.png" target="_self"><br><img alt="Pasted image 20240328153424.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328153424.png" target="_self"><br><img alt="Pasted image 20240328153727.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328153727.png" target="_self"><br><img alt="Pasted image 20240328154035.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328154035.png" target="_self"><br>
微服务是一种经过良好架构设计的分布式架构方案。微服务本质上也是一种分布式方案
<br><img alt="Pasted image 20240328154756.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328154756.png" target="_self"><br>单体架构特点？<br>简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统<br>
分布式架构特点？
<br>松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝<br>
微服务：一种良好的分布式架构方案
<br>优点：拆分粒度更小、服务更独立、耦合度更低
<br>缺点：架构非常复杂，运维、监控、部署难度提高
<br><img alt="Pasted image 20240328162348.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328162348.png" target="_self"><br><img alt="Pasted image 20240328162829.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328162829.png" target="_self"><br><img alt="Pasted image 20240328163053.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328163053.png" target="_self"><br><img alt="Pasted image 20240328163910.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328163910.png" target="_self"><br>OrderService:<br>@Service
public class OrderService { @Autowired private OrderMapper orderMapper; public Order queryOrderById(Long orderId) { // 1.查询订单 Order order = orderMapper.findById(orderId); // 4.返回 return order; }
}
复制<br>UserService:<br>@Service
public class UserService { @Autowired private UserMapper userMapper; public User queryById(Long id) { return userMapper.findById(id); }
}
复制<br><img alt="Pasted image 20240328164940.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328164940.png" target="_self"><br>
实现使用Java代码发送http请求
<br>在order-service的OrderApplication中注册RestTemplate
<br>@MapperScan("cn.itcast.order.mapper")
@SpringBootApplication
public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } @Bean public RestTemplate restTemplate() { return new RestTemplate(); }
}
复制<br>修改order-service中的OrderService的queryOrderById方法：
<br>@Service
public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.查询订单 Order order = orderMapper.findById(orderId); String url = "http://localhost:8081/user/" + order.getUserId(); User user = restTemplate.getForObject(url, User.class); order.setUser(user); // 4.返回 return order; }
}
复制<br>验证<br>
<img alt="Pasted image 20240328170745.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328170745.png" target="_self">
<br>总结：<br>基于RestTemplate发起的http请求实现远程调用
<br>http请求做远程调用是与语言无关的调用，只要知道对方的ip、端口、接口路径、请求参数即可。
<br>
服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）<br>
服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）
<br>服务A调用服务B，服务B调用服务C，那么服务B是什么角色？<br>服务提供者：暴露接口给其它微服务调用
<br>服务消费者：调用其它微服务提供的接口
<br>提供者与消费者角色其实是相对的
<br>一个服务可以同时是服务提供者和服务消费者
<br><img alt="Pasted image 20240401112122.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240401112122.png" target="_self"><br><img alt="Pasted image 20240401112418.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240401112418.png" target="_self"><br>消费者该如何获取服务提供者具体信息？ <br>服务提供者启动时向eureka注册自己的信息
<br>eureka保存这些信息
<br>消费者根据服务名称向eureka拉取提供者信息 <br>如果有多个服务提供者，消费者该如何选择？ <br>服务消费者利用负载均衡算法，从服务列表中挑选一个 <br>消费者如何感知服务提供者健康状态？ <br>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态
<br>eureka会更新记录服务列表信息，心跳不正常会被剔除
<br>消费者就可以拉取到最新的信息 <br>
<br>在Eureka架构中，微服务角色有两类：
<br>EurekaServer：服务端，注册中心 <br>记录服务信息
<br>心跳监控 <br>EurekaClient：客户端 <br>Provider：服务提供者，例如案例中的 user-service <br>注册自己的信息到EurekaServer
<br>每隔30秒向EurekaServer发送心跳 <br>consumer：服务消费者，例如案例中的 order-service <br>根据服务名称从EurekaServer拉取服务列表
<br>基于服务列表做负载均衡，选中一个微服务后发起远程调用 <br>
<br>创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖
<br>&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;
复制<br>
上文中的spring-cloud-starter-netflix-eureka-server的starter表示Eureka服务端的所有服务spring boot都已经帮我们配置好了。我们只需要引入依赖直接使用就好了。
<br>
编写启动类，添加@EnableEurekaServer注解 <br>
添加application.yml文件，编写下面的配置： <br>server: port: 10086
spring: application: name: eurekaserver eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka/
复制<br>
<br>在user-service项目引入spring-cloud-starter-netflix-eureka-client的依赖
<br>&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;
复制<br>在application.yml文件，编写下面的配置：
<br>eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka/
复制<br>启动多个服务实例 <br>
-Dserver.port=8082<br>
<img alt="Pasted image 20240401152524.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240401152524.png" target="_self">
<br><img alt="Pasted image 20240401152912.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240401152912.png" target="_self"><br>
<br>修改OrderService的代码，修改访问的url路径，用服务名代替ip、端口：
<br>String url = "http://userservice/user/" + order.getUserId();
复制<br>在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解：
<br>@Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); }
复制<br>在浏览器中访问http://localhost:8088/order/103<br>
<img alt="Pasted image 20240401155402.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240401155402.png" target="_self">
<br><img alt="Pasted image 20240403101629.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240403101629.png" target="_self"><br>
Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个子接口都是一种规则：
<br><img alt="Pasted image 20240403101937.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240403101937.png" target="_self"><br><img alt="Pasted image 20240403102010.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240403102010.png" target="_self"><br>通过定义IRule实现可以修改负载均衡规则，有两种方式：<br>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：
<br>@Bean
public IRule randomRule(){ return new RandomRule();
}
复制<br>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：
<br>userservice: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #负载均衡规则 复制<br>
第一种方案是全局负载均衡方案配置，配置完之后所有的请求都会使用这个方案进行请求<br>
第二种方案是先配置了服务名称，在配置了负载均衡方案。这种只会在请求这个服务的时候才会使用本方案。其他的请求不使用本方案。
<br>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。<br>
而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：<br>ribbon: eager-load: enabled: true # 开启饥饿加载 clients: userservice # 对userservice这个服务饥饿加载；对一个服务进行饥饿加载 # 对多个服务进行饥饿加载的方法 # - userservice1 # - userservice2
复制<br>
<br>Ribbon负载均衡规则 <br>规则接口是IRule
<br>默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询 <br>负载均衡自定义方式 <br>代码方式：配置灵活，但修改时需要重新打包发布
<br>配置方式：直观，方便，无需重新打包发布，但是无法做全局配置 <br>饥饿加载 <br>开启饥饿加载
<br>指定饥饿加载的微服务名称 <br>Nacos 是阿里巴巴的产品，现在是 SpringCloud 中的一个组件。相比 Eureka 功能更加丰富，在国内受欢迎程度较高。<br>Nacos 是使用 Java 开发的注册中心，所以首先需要在配置 Java 的运行环境。<br>下载并解压 Nacos 安装包：<a data-tooltip-position="top" aria-label="https://github.com/alibaba/nacos" rel="noopener" class="external-link is-unresolved" href="https://github.com/alibaba/nacos" target="_self">下载地址</a>
<br><img alt="Pasted image 20240407110432.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240407110432.png" target="_self"><br>
Nacos 目录结构<br>Bin：启动 Nacos 的可执行目录
<br>Conf：Nacos 的配置文件
<br>Target：Nacos 的 jar 包
<br>通过命令行执行 bin 目录下的脚本启动 Nacos
<br>sh startup.sh -m standalone
复制<br>-m：启动的模式
<br>Standalone：单机启动
<br>验证
<br><img alt="Pasted image 20240407111340.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240407111340.png" target="_self"><br>
访问http://localhost:8848/nacos/index.html查看Nacos主页：<br>
<img alt="Pasted image 20240407111428.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240407111428.png" target="_self"><br>
<br>在 cloud-demo 父工程中添加 spring-cloud-alilbaba 的管理依赖：
<br>&lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud-alibaba.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt;
复制<br>添加 Nacos 客户端依赖
<br>&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt;
复制<br>修改 user-service&amp;order-service 中的 application. Yml 文件，注释 eureka 地址，添加 nacos 地址：
<br>spring: cloud: nacos: server-addr: localhost:8848
复制<br>启动 client 服务并验证
<br><img alt="Pasted image 20240407114815.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240407114815.png" target="_self"><br>Nacos 的服务级别为服务-集群-实例；通过这种分级模型可以大大增加应用的容灾能力。<br>
<img alt="Pasted image 20240407115734.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240407115734.png" target="_self"><br><img alt="Pasted image 20240407120004.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240407120004.png" target="_self"><br>
<br>修改 application. yml，添加如下内容
<br>spring: cloud: nacos: discovery: cluster-name: HZ # 集群名称；例如：HZ，杭州
复制<br>验证
<br><img alt="Pasted image 20240407120800.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240407120800.png" target="_self"><br>
相同集群的实例服务，在调用时优先调用本集群下的服务实例
<br>修改 order-service 中的 application.yml，设置集群为 HZ：
<br>spring: cloud: nacos: discovery: cluster-name: HZ
复制<br>然后在 order-service 中设置负载均衡的 IRule 为 NacosRule，这个规则优先会寻找与自己同集群的服务：
<br>userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule #负载均衡规则
复制<br>Note
NacosRule 负载均衡策略 <br>优先选择同集群服务实例列表
<br>本地集群找不到提供者，才去其它集群寻找，并且会报警告
<br>确定了可用实例列表后，再采用随机负载均衡挑选实例 <br>实际部署中会出现这样的场景：<br>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求<br>
Nacos 提供了权重配置来控制访问频率，权重越大则访问频率越高
<br>在 Nacos 控制台可以设置实例的权重值；
<br>将权重设置为 0.1，测试可以发现 8083 被访问到的频率大大降低：
<br><img alt="Pasted image 20240409110634.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240409110634.png" target="_self"><br>实例的权重控制： <br>Nacos 控制台可以设置实例的权重值，0~1 之间
<br>同集群内的多个实例，权重越高被访问的频率越高
<br>权重设置为 0 则完全不会被访问 <br>权重为 0 的应用场景： <br>在服务上线升级的过程中，如果不能完全中断服务的情况下，不能重启所有服务，可以使用一下方案进行升级：<br>先将一个服务的权重调整为 0 后停止该服务
<br>然后升级重启该服务，先为该服务设置一个叫小的权重如 0.1。
<br>对升级的服务进行小范围测试。如果没有问题的话在调整一个较大的权重。
<br>重复流程升级所有服务。
<br>
Nacos 也是一个数据管理中心
<br>Nacos 中服务存储和数据存储的最外层都是一个名为 namespace 的东西，用来做最外层隔离<br>
<img alt="Pasted image 20240409112311.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240409112311.png" target="_self"><br>Namespace： 上文说的集群是根据业务做分类隔离。但是在实际开发过程中还存在开发、测试、生产不同的应用环境。Namespace 就是用来做不同应用环境之间的隔离。所以不同 Namespace 之间数据不互通。
<br>Group：可以把业务相关度比较高的服务放到一个组里。比如支付和订单服务；一般情况也不会配置 Group
<br>不同命名空间下的服务是不通的！<br>在 Nacos 控制台可以创建 namespace，用来隔离不同环境
<br><img alt="Pasted image 20240409113044.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240409113044.png" target="_self"><br>修改 order-service 的 application.yml，添加 namespace：
<br>spring: cloud: nacos: discovery: namespace: 800c8373-69de-4f5d-ba98-57d2cd0d5915 # 命名空间的ID
复制<br>重启 Orderservice 并在浏览器访问测试：
<br><img alt="Pasted image 20240409113556.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240409113556.png" target="_self"><br>空间之间数据不互通。所以 order service 访问不了 user service：<br>
<img alt="Pasted image 20240409113607.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240409113607.png" target="_self"><br>Note
Nacos 环境隔离:<br>
每个 namespace 都有唯一 id<br>
服务设置 namespace 时要写 id 而不是名称<br>
不同 namespace 下的服务互相不可见
<br>服务注册到 Nacos 时，可以选择注册为临时或非临时实例，通过下面的配置来设置：<br>spring: cloud: nacos: discovery: ephemeral: false # 设置为非临时实例
复制<br>临时实例宕机时，会从 nacos 的服务列表中剔除，而非临时实例则不会<br><img alt="Pasted image 20240409114515.png" src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240409114515.png" target="_self"><br>Nacos 与 eureka 的共同点 <br>都支持服务注册和服务定时拉取
<br>都支持服务提供者心跳方式做健康检测 <br>Nacos 与 Eureka 的区别 <br>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
<br>Nacos临时实例心跳不正常会被剔除，非临时实例则不会被剔除
<br>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时。Eureka 不支持主动推送
<br>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka 采用 AP 方式]]></description><link>https://whiteclouds1971.github.io/001-读书笔记/it黑马微服务/实用篇/day01-springcloud01.html</link><guid isPermaLink="false">001 读书笔记/IT黑马微服务/实用篇/day01-SpringCloud01.md</guid><dc:creator><![CDATA[白云]]></dc:creator><pubDate>Tue, 09 Apr 2024 03:52:40 GMT</pubDate><enclosure url="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328161731.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://whiteclouds1971.github.io/$/$sys999-attachment/pasted-image-20240328161731.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>